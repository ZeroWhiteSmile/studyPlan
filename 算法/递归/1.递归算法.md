# 递归
## 概述
* 程序调用自身的编程技巧称为递归（ recursion）。递归做为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。一般来说，递归需要有边界条件、递归前进段和递归返回段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。

* recursion 英 /rɪ'kɜːʃ(ə)n/ n. [数] 递归，循环；递归式 

## 递归定义
* 递归，就是在运行的过程中调用自己。
* 构成递归需具备的条件：
>1. 子问题须与原始问题为同样的事，且更为简单；
>1. 不能无限制地调用本身，须有个出口，化简为非递归状况处理。

* 在数学和计算机科学中，递归指由一种（或多种）简单的基本情况定义的一类对象或方法，并规定其他所有情况都能被还原为其基本情况。

* 斐波纳契数列（Fibonacci Sequence）
>* 又称黄金分割数列，又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34..... I。如果设F(n）为该数列的第n项（n>=3，n∈N*），那么这句话可以写成如下形式：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n>=3，n∈N*）
>* **注意: n >= 3 后 f(n) = n**
>* **注意: n∈N* ：n属于正整数,或是说n是正整数N*集合的一个元素**
>* 斐波纳契数列是典型的递归案例：

* 递归关系就是实体自己和自己建立关系。
>* Fib(0) = 1 [基本情况] 
>* Fib(1) = 1 [基本情况] 
>* 对所有（n>=3，n∈N*）的整数：Fib(n) = (Fib(n-1) + Fib(n-2)) [递归定义] 


* 尽管有许多数学函数均可以递归表示，但在实际应用中，递归定义的**高开销**往往会让人望而却步。例如：
>* 阶乘
>* （1) = 1 [基本情况] 对所有（n>=3，n∈N*）的整数：阶乘（n) = (n * 阶乘（n-1))[递归定义] 

* 一种便于理解的心理模型，是认为递归定义对对象的定义是按照“先前定义的”同类对象来定义的。例如：你怎样才能移动100个箱子？答案：你首先移动一个箱子，并记下它移动到的位置，然后再去解决较小的问题：你怎样才能移动99个箱子？最终，你的问题将变为怎样移动一个箱子，而这时你已经知道该怎么做的。
 
* 如此的定义在数学中十分常见。例如，**集合论**对自然数的正式定义是：1是一个自然数，每个自然数都有一个后继，这一个后继也是自然数。
 
* **德罗斯特效应**是递归的一种视觉形式。图中女性手持的物体中有一幅她本人手持同一物体的小图片，进而小图片中还有更小的一幅她手持同一物体的图片，依此类推。

* 又例如，我们在**两面相对的镜子之间放一根正在燃烧的蜡烛**，我们会从其中一面镜子里看到一根蜡烛，蜡烛后面又有一面镜子，镜子里面又有一根蜡烛……这也是递归的表现。

<img src='img/dl.png' />

## 递归应用

* 递归算法一般用于解决三类问题：
1. 数据的定义是按递归定义的。（Fibonacci函数）
2. 问题解法按递归算法实现。
* 这类问题虽则本身没有明显的递归结构，但用递归求解比迭代求解更简单，如Hanoi问题。
3. 数据的结构形式是按递归定义的。
* 如二叉树、广义表等，由于结构本身固有的递归特性，则它们的操作可递归地描述。

## 递归的缺点：

* 递归算法解题相对常用的算法如普通循环等，**运行效率较低**。因此，应该尽量避免使用递归，除非没有更好的算法或者某种特定情况，递归更为适合的时候。在递归调用的过程当中**系统为每一层的返回点、局部量等开辟了栈来存储**。递归次数过多容易造成**栈溢出**等。
