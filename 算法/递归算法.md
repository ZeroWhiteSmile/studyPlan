# JS递归方法
## 概述
>* 程序调用自身的编程技巧称为递归（ recursion）。递归做为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。一般来说，递归需要有边界条件、递归前进段和递归返回段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。
>* recursion 英 /rɪ'kɜːʃ(ə)n/ n. [数] 递归，循环；递归式 

## 递归定义
>* 递归，就是在运行的过程中调用自己。
>* 构成递归需具备的条件：
>>1. 子问题须与原始问题为同样的事，且更为简单；
>>1. 不能无限制地调用本身，须有个出口，化简为非递归状况处理。
>
>* 在数学和计算机科学中，递归指由一种（或多种）简单的基本情况定义的一类对象或方法，并规定其他所有情况都能被还原为其基本情况。
>
>* **斐波纳契数列**（Fibonacci Sequence），又称黄金分割数列，又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34..... I。如果设F(n）为该数列的第n项（n>=3，n∈N*），那么这句话可以写成如下形式：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n>=3，n∈N*）
>* **注意: n >= 3 后 f(n) = n**
>* **注意: n∈N* ：n属于正整数,或是说n是正整数N*集合的一个元素**
>> 
>>1. 斐波纳契数列是典型的递归案例：
>>>* 递归关系就是实体自己和自己建立关系。
>>>* Fib(0) = 1 [基本情况] Fib(1) = 1 [基本情况] 对所有（n>=3，n∈N*）的整数：Fib(n) = (Fib(n-1) + Fib(n-2)) [递归定义] 
>>
>>2. 尽管有许多数学函数均可以递归表示，但在实际应用中，递归定义的高开销往往会让人望而却步。例如：
>>> 
>>>*  **阶乘**（1) = 1 [基本情况] 对所有（n>=3，n∈N*）的整数：**阶乘（n) = (n * 阶乘（n-1))**[递归定义] 
>>> 
>>>* 一种便于理解的心理模型，是认为递归定义对对象的定义是按照“先前定义的”同类对象来定义的。例如：你怎样才能移动100个箱子？答案：你首先移动一个箱子，并记下它移动到的位置，然后再去解决较小的问题：你怎样才能移动99个箱子？最终，你的问题将变为怎样移动一个箱子，而这时你已经知道该怎么做的。
>>> 
>>>* 如此的定义在数学中十分常见。例如，**集合论**对自然数的正式定义是：1是一个自然数，每个自然数都有一个后继，这一个后继也是自然数。
>>> 
>>>* **德罗斯特效应**是递归的一种视觉形式。图中女性手持的物体中有一幅她本人手持同一物体的小图片，进而小图片中还有更小的一幅她手持同一物体的图片，依此类推。
>>>> 
>>>* 又例如，我们在**两面相对的镜子之间放一根正在燃烧的蜡烛**，我们会从其中一面镜子里看到一根蜡烛，蜡烛后面又有一面镜子，镜子里面又有一根蜡烛……这也是递归的表现。

## 递归应用
>* 递归算法一般用于解决三类问题：
>>1. 数据的定义是按递归定义的。（Fibonacci函数）
>>2. 问题解法按递归算法实现。
>>>>* 这类问题虽则本身没有明显的递归结构，但用递归求解比迭代求解更简单，如Hanoi问题。
>>3. 数据的结构形式是按递归定义的。
>>>>* 如二叉树、广义表等，由于结构本身固有的递归特性，则它们的操作可递归地描述。

## 递归的缺点：
>>* 递归算法解题相对常用的算法如普通循环等，**运行效率较低**。因此，应该尽量避免使用递归，除非没有更好的算法或者某种特定情况，递归更为适合的时候。在递归调用的过程当中**系统为每一层的返回点、局部量等开辟了栈来存储**。递归次数过多容易造成**栈溢出**等。

## 递归典型问题： 
>###1.  梵塔问题（汉诺塔问题）<img src='../hanoitower.jpg' width='300' />
>>* 相传在古印度圣庙中，有一种被称为汉诺塔(Hanoi)的游戏。该游戏是在一块铜板装置上，有三根杆(编号A、B、C)，在A杆自下而上、由大到小按顺序放置64个金盘(如下图)。游戏的目标：把A杆上的金盘全部移到C杆上，并仍保持原有顺序叠好。**操作规则**：每次只能移动**一个盘子**，并且在移动过程中**三根杆上都始终保持大盘在下，小盘在上**，操作过程中盘子可以置于**A、B、C任一杆上**，找出移动次数最小的方案.
>>>* 如果将这个问题的盘子数量减为10个或更少，就不会有太大的问题了。但盘子数量为64的话，你一共需要移动约1800亿亿步（18,446,744,073,709,551,615），才能最终完成整个过程。这是一个天文数字，没有人能够在有生之年通过手动的方式来完成它。即使借助于计算机，假设计算机每秒能够移动100万步，那么约需要18万亿秒，即58万年。将计算机的速度再提高1000倍，即每秒10亿步，也需要584年才能够完成。
>>>#### 算法实现：
>>>>1. (A->C->B)先将A上的n-1个盘子通过C移动到B(移动到C上从上到下是**大到小**,再移动到B上从上到下是**小到大**)
>>>>2. (A->C)将A上的最后一个盘子直接移动到C
>>>>3. (B->A->C)将B上的n-1的盘子通过A移动到C即可实现(移动到A上从上到下是**大到小**,在移动到C上从上到下是**小到大**)
>>>>##### c++ 程序如下:
>>>>
>>>>		/*
>>>>		* buffer 英 /'bʌfə/ n. [计] 缓冲区；缓冲器，[车辆] 减震器 vt. 缓冲
>>>>		* disk 英 /dɪsk/ n. [计] 磁盘，磁碟片；圆盘，盘状物；唱片
>>>>		*/
>>>>		int  steps = 0;
>>>>		#include <iostream>
>>>>		using namespace std;	
>>>>		void hanoiTower(int n, char A, char B, char C){
>>>>			if (n == 1) {
>>>>				cout<< "将编号为" << n << "的盘子从" << A << "移动到" << C << endl;
>>>>			} else {
>>>>				hanoiTower(n - 1, A, C, B);  
>>>>				// ACB改变了参数位置，也就改变了值，此时参数ABC对应'A''C''B'
>>>>				cout<< "将编号为" << n << "的盘子从" << A << "移动到" << C << endl;
>>>>				hanoiTower(n - 1, B, A, C);
>>>>				// BAC改变了参数位置，也就改变了值，此时参数ABC对应'B''A''C'
>>>>			}
>>>>			steps += 1;
>>>>		}
>>>>		int main(){
>>>>			int num;
>>>>			cout<< "Enter the number of disk:";
>>>>			cin>> num; 
>>>>			hanoiTower(num, 'A', 'B', 'C');
>>>>			cout << "总共需要" << steps << "步" << endl;
>>>>		    system('PAUSE');
>>>>			return 0;
>>>>		}
>>>> <img src='../hanoiTowerC++.png' />
>>>> <img src='../hanoiTowerC++Debug1.png' />
>>>> <img src='../hanoiTowerC++Debug2.png' />
>>>>
>>>>##### js程序如下:
>>>>	 let steps = 0
>>>>	 function hanoiTower(n, A, B, C) {
>>>>	 	if (n === 1) {
>>>>	 		console.log('将编号为'+ n + '的盘子从' + A + '移动到' + C)
>>>>	 	} else {
>>>>	 		hanoiTower(n - 1, A, C, B)
>>>>	 		console.log('将编号为'+ n + '的盘子从' + A + '移动到' + C)
>>>>	 		hanoiTower(n - 1, B, A, C)
>>>>	 	}
>>>>	 	steps += 1
>>>>	 	console.log('移动步数', steps)
>>>>	 }
>>>>	 hanoiTower(10, 'A', 'B', 'C')
>>>> <img src='../hanoiTowerJS.png' />
>>>>
>>>>##### python程序如下:
>>>>		# !E:/softwareDirectory/Python37 #文件目录
>>>>		# -*- coding: UTF-8 -*-
>>>>		#coding=utf-8
>>>>
>>>>		steps = 0
>>>>		def hanoiTower(n, A, B, C):
>>>>    		if n == 1:
>>>>        		print('将编号为', n, '盘子从', A, '移动到', C)
>>>>    		else:
>>>>        		hanoiTower(n - 1, A, C, B)
>>>>        		print('将编号为', n, '盘子从', A, '移动到', C)
>>>>        		hanoiTower(n - 1, B, A, C)
>>>>    			global steps
>>>>    			''' 在函数内部对变量赋值进行修改后，该变量就会被Python解释器认为是局部变量而非全局变量，
>>>>        			程序执行到steps +=1 的时候，因为这条语句是给a赋值，所以a成为了局部变量，
>>>>					那么在执行return a(或是print a)的时候，因为a这个局部变量还没有定义，自然就会抛出这样的错误。
>>>>        			当全局变量来看，就是使用global关键字，在函数内部先声明a这个变量是全局变量。
>>>>    			'''
>>>>    			steps += 1
>>>>    			print(steps)
>>>>
>>>>				hanoiTower(10, 'A', 'B', 'C')
>>>> <img src='../hanoiTowerPython.png' />

## 递归例子：求数组中的最大数
>> 

## 递归例子:斐波纳契数列的运用：
>1 楼梯有n阶台阶，上楼可以一步上1阶，也可以一步上2阶，编一程序计算共有多少种不同的走法.
> 
>>#### 算法实现:
>>
>>* （**斐波纳契数列**：如果设F(n）为该数列的第n项（n>=3，n∈N*），那么这句话可以写成如下形式：<b>F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n>=3，n∈N*）</b> | 1、1、2、3、5、8、13、21、34..... I）
>>>* 设n阶台阶的走法为f(n)
>>>* 设n = 1（一步上1台阶）
>>>  **f(1) = 1**
>>>* 设n = 2（一步上1台阶在1台阶）
>>>  **f(2) = 2**
>>>* 设n = 3（一步上一台阶在1台阶再1台阶，一步上1台阶再2台阶，一步上2台阶在1台阶）
>>> **f(3) = f(3 - 1) + f(3 - 2) =f(2) + f(1) = 2 + 1 = 3**
>>
>>>* #### c++程序:
>>>		#include <iostream>
>>>		using namespace std;
>>>		void stairSteps (int n) {
>>>		    if (n > 0) {
>>>		        if (n == 1) {
>>>		            return 1;
>>>		        } else if (n == 2) {
>>>		            return 2;
>>>		        } else {
>>>		            return stairSteps(n - 1) + stairSteps(n - 2);
>>>		        }
>>>		    } else {
>>>		        return 0
>>>		    }
>>>		};
>>>		int main () {
>>>		    int n;
>>>		    cin>>n;
>>>		    cout<<stairSteps(n)<<endl;
>>>		    getchar();
>>>		    system('PAUSE');
>>>		    return 0;
>>>		}
>>> 
>2 楼梯有n阶台阶，上楼可以一步上1阶，也可以一步上2阶，也可以一步上3阶，编一程序计算共有多少种不同的走法.
>
>>#### 算法实现:
>>
>>* 待解决 
>
## 递归例2-快速排序
>* 快速排序（Quicksort）是对冒泡排序的一种改进。
>* 快速排序由C. A. R. Hoare在1960年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。
>### 算法介绍 
>>* 设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它左边，所有比它大的数都放到它右边，这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。
一趟快速排序的算法是：
>>>* 1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；
>>>* 2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；
>>>* 3）从j开始向前搜索，即由后开始向前搜索(j--)，找到第一个小于key的值A[j]，将A[j]和A[i]的值交换；
>>>* 4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]的值交换；
>>>* 5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。
>>
>### 排序演示
>>* 假设用户输入了如下数组：
>>>* 下标 | 0 | 1 | 2 | 3 | 4 | 5 |
>>>* 数据 | 6 | 2 | 7 | 3 | 8 | 9 |
>>* 创建变量i=0（指向第一个数据）, j=5(指向最后一个数据), k=6(赋值为第一个数据的值)。
>>* **第一次比较:**我们要把所有比k小的数移动到k的左面，所以我们可以开始寻找比6小的数，从j开始，从右往左找，不断递减变量j的值，我们找到第一个下标3的数据比6小，于是把数据3移到下标0的位置，把下标0的数据6移到下标3，完成第一次比较：
>>>* 下标 |   0   | 1 | 2 | 3 |   4   | 5 |
>>>* 数据 | **3** | 2 | 7 | **6** | 8 | 9 |
>>>* i=0 j=3 k=6
>>* **第二次比较:**接着，开始第二次比较，这次要变成找比k大的了，而且要从前往后找了。递加变量i，发现下标2的数据是第一个比k大的，于是用下标2的数据7和j指向的下标3的数据的6做交换，数据状态变成下表：
>>>* 下标 | 0 | 1 |   2   |   3   | 4 | 5 |
>>>* 数据 | 3 | 2 | **6** | **7** | 8 | 9 |
>>>* i=2 j=3 k=6
>>* 称上面两次比较为一个循环。
>>* 接着，再递减变量j，不断重复进行上面的循环比较。
>>* 在本例中，我们进行一次循环，就发现i和j“碰头”了：他们都指向了下标2。于是，第一遍比较结束。得到结果如下，凡是k(=6)左边的数都比它小，凡是k右边的数都比它大：
>>* 如果i和j没有碰头的话，就**递加i找大的**，还没有，就再**递减j找小的**，如此反复，不断循环。注意判断和寻找是同时进行的。
>>* 然后，对k两边的数据，再分组分别进行上述的过程，直到不能再分组为止。
>>* 注意：第一遍快速排序不会直接得到最终结果，只会把比k大和比k小的数分到k的两边。为了得到最后结果，需要再次对下标2两边的数组分别执行此步骤，然后再分解数组，直到数组不能再分解为止（只有一个数据），才能得到正确结果。
>>>
>> 
>### c++程序：
>		
>		#include <iostream>;
>		using namespace std;
>		void quickSort (int arr[], int low, int height) {
>			
>		}
>		