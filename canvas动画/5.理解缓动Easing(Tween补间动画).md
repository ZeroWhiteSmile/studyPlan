## 理解缓动Easing(Tween补间动画)(解释Penner[Robert Penner一个计算机软件工程师]方程)- JavaScript和ActionScrip

(原文地址：http://blog.moagrius.com/actionscript/jsas-understanding-easing/#r1)

tween （补间动画） 英 /twiːn/  美 /twin/ prep. 在……之间 n. 10至12岁之间的少年

尽管经典的缓和方程式很常见，主要归功于Penner，但似乎并没有深入研究现在很多代码所遵循的“它是如何工作的”。

首先，快速澄清最流行的缓动类。

“标准”缓动类（提供可预测的惯性）是线性(Linear)，四线(Quad)，立方(Cubic)，夸脱(Quart)，（五次[Quintic]或强[Strong]）

Linear /'lɪnɪɚ/ n. (Linear) adj. (linear) 线形的；线条构成的；一维的；直线的；连续的；长度的；涉及一连串直接相关的事物的
Quad 英 /kwɒd/  美 /kwɑd/ n.四方院子；四胞胎之一；嵌条；成套的四件东西
Quadratic 英 /kwɒ'drætɪk/  美 /kwɑ'drætɪk/ adj. [数] 二次的 n. 二次方程式
Cubic 英 /'kjuːbɪk/  美 /'kjubɪk/ adj. 立方体的，立方的
Quart 英 /kwɔːt/  美 /kwɔrt/ n. 夸脱（容量单位）；一夸脱的容器 复数 quarts
Quintic 英 /'kwɪntɪk/ adj.（数学）五次方的；五次的
Strong 英 /strɒŋ/  美 /strɔŋ/ adj. 坚强的；强壮的；牢固的；擅长的 adv. 强劲地；猛烈地
Expo 英 /'ekspəʊ/  美 /'ɛkspo/ n. 展览会

几乎都是相同的。它们之间的唯一区别是变化乘以其自身的次数。例如，如果具有easeOut(即缓动发生在出口处)的动画中的特定点应该产生一个位置（也就是补间过程的90%），例如0.9,你可以用0.9乘以它本身的“幂”。如果这个方法的幂是3，它就是0.9 * 0.9 * 0.9 = 0.729, 代替0.9。这意味着它会更“dramatic（戏剧化）”——对于easeIn(缓动发生在入口处)，开始会更快，结束时会更慢。

这五个标准类使用1 - 5的幂。

Linear = 1 （任何数的1次方都是它自己，所以在过渡过程的10%处，该属性将添加开始和结束之间总差的10%）
Quad = 2
Cubic = 3
Quart = 4
Quint and Strong = 5
(Expo)

是的，Quintic和Strong是一样的。

Expo使用10次幂，但也应用其他一些检查，所以我没有将它包含在上面的5个标准类中。

另外，更神奇的easing Classes（缓动类）通常只是应用稍微不同的数学方法，正弦easing class仅仅使用 Math.cos (easeIn) and Math.sin (easeOut)，创造更多变化在一端（开始easeIn， 结束easeOut）,铺平曲线的另一端。Bounce和Elastic提供了一些更复杂的算法，超出了本文的范围，所以我将继续……

这些函数通常用4个参数来编写:
```
function noEasing (t, b, c, d) {
	return c * t / d + b;
}

@t 是tween（补间动画）当前时间(或者位置)，可以是秒，也可以是帧，步数，秒，毫秒，无论如何-只要所用的单位与所用的总时间相同。
@b 是属性的初始值。
@c 属性的开始值和终点值之间的变化值
@d tween（补间动画）的总时间
```

我们把这个分解一下，假如你的Tweening对象水平通过这个屏幕，让我们陈述一些事实：
——它最初在50（所以在JS/DOM中，它的位置是:absolute，left:50px,在AS中，它有element.x = 50)。
——你想要Tween它到位置200。
——你想要Tween它花费1秒。

在tween开始，传递给easing 函数的值是：
——t = 0 (我们刚刚开始，所以0秒过去了)
——b = 50 (正在Tweened的属性的初始值)
——c = 150（变化值-所以目标值200减去开始值50等于150）
——d = 1(总时长1秒)

所以用上面的线型数学：
```
c * t / d + b
```

虽然数学是一样的，但我更喜欢这样看:
```
c * ( t / d ) + b
```

括号内的部分是完成的百分比...过去的时间(t)除以总持续时间(d)。如果30毫秒已经结束，总持续时间是50毫秒，30 / 50 = 0.6，或者说过渡过程的60%。这个数字运行你的tween（补间），其他的都可以从这个值中推断出来。

回到例子… 如上所述，我们知道在tween（补间）的开始，c是150 t是0 d是1 b是50

所以 150 * 0 / 1 + 50 = 50

这个元素，在tween（补间）的开始，仍然是50px -没有变化。

现在让我们看看过渡到一半时会发生什么：
——t = 0.5 (补间进行到一半，所以是0.5对于1秒来说)
——b = 50 ( 开始补间动画的初始值)
——c = 150 (变化值-所以目标值200减去开始值50等于150)
——d = 1 (总时长1秒)

您将看到只有“t”参数更改了——原来的值，变化值，总持续时间均不变。让我们看看如何改变过去时间来影响返回值。

公式是一样的:c * t / d + b，但是现在更新的“t”值(过去时间)发生了变化，所以

——150 * 0.5 / 1 + 50 = 125

现在，easing函数返回125，将元素定位为top/x(125)。这实际上是50(开始)和200(结束)之间的一半，并且比原始值增加了75个像素。

把它分解一下，我们总是想要添加起始值(b)。tween（补间）会改变属性相对于初始值，所以我们总是把变化量加到b上

——b +(相对变化量)

我们知道t / d代表百分比

——所以 0.5 / 1 = 0.5, or 50%

补间结束时值的总变化值——起始值和目标值之间的差值-为150(“c”参数)

150的50%等于75。这是过渡点这一点的相对变化量。

将相对变化量(75)与原始值“b”(50)相加，就得到当前位置125。简单的。

同样，你也会注意到所有的魔术都发生在这里:
c * t / d + b

几乎所有的简化计算，它总是随着时间(一些浮点数)的变化而变化加上初始值,如何计算浮点数(时间)决定了过渡期间任何点的返回值

事实上，对于任何补间，你可以用@b（初始值）和@c（变化值）替换0和1，分别——函数的返回值将是0到1之间的一个数字。乘以开始值（过去时间）和结束值（总时间）之间的差，把它加到起始值，效果是一样的。
```
var factor = yourEasingFunction(currentTime, 0, 1, totalTime)
target.property = original.value + (destination.value - original.value) * factor
```

factor 系数 英 /'fæktə/  美 /'fæktɚ/ n. 因素；要素；[物] 因数；代理人 vi. 做代理商 vt. 把…作为因素计入；代理经营；把…分解成
original 初始点 英 /ə'rɪdʒɪn(ə)l; ɒ-/  美 /ə'rɪdʒənl/ adj. 原来的；开始的；首创的，新颖的，创新的；原作的 n. 原件，原版；（文学中）原型；（歌，画等的）原创作品；原版唱片；真品原版服装；古怪的人
destination 终点 英 /,destɪ'neɪʃ(ə)n/  美 /,dɛstɪ'neʃən/ n. 目的地，终点

事实上，你甚至可以从一个缓动函数中省略这些参数——下面的工作几乎与任何标准缓动类的easeIn版本相同:
```
return Math.pow(t / d, <power>);
```

所以这个函数只需要两个参数，开始时间和总时间，其中“power（幂）”是每个类引用的数量(上面)，模仿Strong.easeIn(即缓动发生在入口处)，例如，下面的函数将执行相同的操作：
```
function easeIn(t, d){
  return Math.pow(t / d, 5);
}
```

easeOut(即缓动发生在出口处)非常类似:
```
return 1 - Math.pow(1 - (t / d), <power>);
```

如此Strong easeOut应该是这样的:
```
function strongEaseOut(t, d){
  return 1 - Math.pow(1 - (t / d), 5);
}
```

您甚至可以编写一个非常简单的函子，使它的数值大于5，或者使用浮动版本……
```
function easeOut(v){
	return function(t, b, c, d){
		return 1 - Math.pow(1 - (t / d), v);
	}
}
```

它将作为调用的返回而传递，而不是作为引用。下面的psudo -code演示了如何使用上面的概念来创建介于四次和五次之间的缓动:
```
SomeTween.performTween(target, duration, props, easeOut(4.5));
```

你也可以使用相同的概念来定制easeBack函数，以创造或多或少的戏剧性返回:
```
	function easeBack(v){
		if(typeof v == 'undefined') v = 1.70158;
		return function(t, b, c, d) {
			return c * ((t = t / d - 1) * t * ((v + 1) * t + v) + 1) + b;
		}
	}
```
