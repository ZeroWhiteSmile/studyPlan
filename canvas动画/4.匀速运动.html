<html !DOCTYPE>
<html>
<head>
  <meta http-equiv='Content-Type' content='text/html;charset=utf-8' />
</head>
<body>
  <canvas id='canvas' width="600" height="200" style='border:solid 1px #f00;'></canvas>

<script type="text/javascript">
window.onload = () => {
  // 全局常量定义
  const canvas = document.getElementById('canvas')
  const ctx = canvas.getContext('2d')
  const canvasW = canvas.width // 必须canvas定义属性width
  const canvasH = canvas.height // 必须canvas定义属性height

  /***
   * @params positionX: 位置
   * @params time: 时间
   * @params velocity: 速度
   * @params distanceX: 距离
   * @params totalTime: 总时间
   * @params beginingPositionX: 开始位置
   * @params 速度 = 距离 ÷ 总时间 velocity = distance ÷ totalTime
   * @params 位置 = 时间 × 速度 positionX = time × velocity
   * @params 位置 = 时间 × (距离 / 总时间) positionX = time × (distance ÷ totalTime)
   * @discription 方法: positionX = time * (distance / totalTime) + beginingPositionX
   * @discription x轴 y轴运动速度不一样，因为距离不一样
   */
    // 定义参数
    let rectW = 10 // 绘制矩形的宽度
    let rectH = 10 // 绘制矩形的高度
    let time = 0
    let positionX = 0 // x位置
    let positionY = 0 // Y位置
    let distanceX = canvasW - rectW  // x距离
    let distanceY = canvasH - rectH // x距离
    let totalTime = 100  // 2000毫秒
    let beginingPositionX = 0  // X开始位置
    let beginingPositionY = 0  // Y开始位置
    let uniformMotion = () => {
      let xSportiveInterval = setInterval(() => {
        /***
         * 从原点开始x轴运动 
         */
        time += 1 // 1毫秒
        positionX = time * (distanceX / totalTime) + beginingPositionX
        ctx.clearRect(0, 0, canvasW, canvasH)
        ctx.fillStyle = '#8a2be2'
        ctx.fillRect(positionX, 0, rectW, rectH)
        if (positionX >= distanceX) {
          clearInterval(xSportiveInterval) // 到达边界停止
          /***
           * 时间清0 重新开始新的循环
           * 开始y轴运动
           */
          time = 0
          let ySportiveInterval = setInterval(() => {
            time += 1
            positionY = time * (distanceY / totalTime) + beginingPositionY
            ctx.clearRect(0, 0, canvasW, canvasH)
            ctx.fillRect(positionX, positionY, rectW, rectH)
            if (positionY >= distanceY) {
              clearInterval(ySportiveInterval) // 到达边界停止
              /***
               * 时间清0 重新开始新的循环
               * 负x轴运动
               */
              time = 0
              let minusXSportiveInterval = setInterval(() => {
                time += 1
                let minusPositionX = time * (distanceX / totalTime) + beginingPositionX
                ctx.clearRect(0, 0, canvasW, canvasH)
                ctx.fillRect(positionX - minusPositionX, positionY, rectW, rectH)
                if (positionX - minusPositionX <= 0) {
                  clearInterval(minusXSportiveInterval)
                  /***
                   * 时间清0 重新开始新的循环
                   * 负y轴运动
                   */
                  time = 0
                  let minusYSportiveInterval = setInterval(() => {
                    time += 1
                    let minusPositionY = time * (distanceY / totalTime) + beginingPositionY
                    ctx.clearRect(0, 0, canvasW, canvasH)
                    ctx.fillRect(0, positionY - minusPositionY, rectW, rectH)
                    if (positionY - minusPositionY <= 0) {
                      clearInterval(minusYSportiveInterval)
                      /***
                       * 递归循环自己
                       * TODO: 时间清0 重新开始
                       */
                      time = 0
                      uniformMotion()
                    }
                  }, 16.6)
                }
              }, 16.6)
            }
          }, 16.6)
        }
      }, 16.6)
   }
   uniformMotion()
}
</script>
</body>
</html>
</html>